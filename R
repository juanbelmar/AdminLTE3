#' @title Card-like 'HTML' element
#' @param title the title of the card
#' @param ... the body content of the card
#' @param body_main,body_side used by \code{card2}, the body
#' content of the front and back sides of the card
#' @param footer the footer of the card; will be hidden if
#' \code{footer=NULL}
#' @param tools a list of tools or badges to be displayed at
#' top-right corner, generated by \code{\link{as_badge}} or
#' \code{\link{card_tool}}
#' @param inputId the id of the card
#' @param class the 'HTML' class of the entire card
#' @param class_header the the 'HTML' class of the card header
#' @param class_body the the 'HTML' class of the card body
#' @param class_foot the the 'HTML' class of the card footer
#' @param style_header 'CSS' style of the header
#' @param style_body 'CSS' style of the body
#' @param start_collapsed whether the card starts as collapsed
#' @param resizable whether the card body can be resized vertically;
#' notice that if true, then the default padding for body will be zero
#' @param root_path see \code{\link{template_root}}
#' @param session shiny session domain
#' @param method action to expand, minimize, or remove the cards;
#' choices are \code{"collapse"}, \code{"expand"}, \code{"remove"},
#' \code{"toggle"}, \code{"maximize"}, \code{"minimize"},
#' and \code{"toggleMaximize"}
#' @return 'HTML' tags
#'
#' @examples
#' library(shiny)
#' library(shidashi)
#'
#' # Used for example only
#' ns <- I
#' session <- MockShinySession$new()
#'
#' # -------------- Basic usage -------------
#' card(
#'   title = "Badges", div(
#'     class = "padding-20",
#'     p(
#'       "Add badges to the top-right corder. ",
#'       "Use \"|\" to indicate the badge classes; ",
#'       "for example: \"badge-info\", \"badge-warning\"..."
#'     ),
#'     hr(), p(
#'       "Use `resizable = TRUE` to make card resizable."
#'     )
#'   ),
#'   tools = list(
#'     as_badge("New|badge-info"),
#'     as_badge("3|badge-warning")
#'   ),
#'   class_body = "height-300",
#'   resizable = TRUE
#' )
#'
#' # ---------------- With tools -----------------
#' card(
#'   title = "Default Tools",
#'   plotOutput(
#'     ns("card_defaulttool_plot"),
#'     height = "100%"
#'   ),
#'   tools = list(
#'     card_tool(
#'       widget = "link",
#'       href = "https://github.com/dipterix"
#'     ),
#'     card_tool(widget = "collapse"),
#'     card_tool(widget = "maximize")
#'   ),
#'   class_body = "height-300",
#'   resizable = TRUE
#' )
#'
#' # -------------- Card2 example --------------
#' card2(
#'   title = "Card2 Example", body_main =
#'     plotOutput(
#'     outputId = ns("card2_plot"),
#'     height = "100%"
#'   ),
#'   body_side = fluidRow(
#'     column(
#'       6L, textInput(
#'         ns("card2_plot_title"),
#'         "Plot title"
#'       )
#'     ),
#'     column(
#'       6L, sliderInput(
#'         ns("card2_plot_npts"),
#'         "# of points", min = 1, max = 100,
#'         value = 10, step = 1, round = TRUE
#'       )
#'     )
#'   ),
#'   tools = list(
#'     card_tool(widget = "link",
#'               href = "https://github.com/dipterix"),
#'     card_tool(widget = "collapse"),
#'     card_tool(widget = "maximize")
#'   ),
#'   class_body = "height-300"
#' )
#'
#' @export
card <- function(
  title, ..., footer = NULL, tools = NULL, inputId = NULL,
  class = "", class_header = "", class_body = "", class_foot = "",
  style_header = NULL, style_body = NULL, start_collapsed = FALSE,
  resizable = FALSE, root_path = template_root()){

  call <- match.call()
  body <- shiny::tagList(...)

  template_path <- file.path(root_path, 'views', 'card.html')

  if(length(title) >= 1){
    data_title <- trimws(as.character(title[[1]])[[1]])
  } else {
    data_title <- ""
  }

  if(length(footer)){
    footer <- shiny::div(
      class = combine_class("card-footer", class_foot),
      footer
    )
  } else {
    footer <- ''
  }

  if(length(tools)){
    tools <- shiny::div(
      class = "card-tools",
      tools
    )
  } else {
    tools <- ""
  }

  if(length(inputId) == 1){
    if(grepl("[\"']", inputId)){
      stop("`card` ID cannot contain quotation marks.")
    }
    card_id <- sprintf(" id='%s'", inputId)
  } else {
    card_id <- ''
  }

  if(resizable){
    default_class_body <- "height-400 resize-vertical flex-container no-padding"
    if(length(class_body)){
      class_body <- unlist(strsplit(class_body, " "))
      if(length(class_body)){
        tmp <- class_body[
          startsWith(class_body, "height-") |
            startsWith(class_body, "min-height-")
        ]
        size <- sapply(strsplit(tmp, "-"), function(x){ x[[length(x)]] })
        if(length(size)){
          suppressWarnings({
            size <- as.numeric(size)
            size <- size[!is.na(size)]
            if(length(size) && size %% 50 == 0){
              default_class_body <- "resize-vertical flex-container no-padding"
            }
          })
        }
      }
    }
    class_body <- combine_class(
      default_class_body,
      class_body
    )
    body <- flex_item(
      class = "fill-height fill-width fill-max-width",
      body
    )
  } else {
    class_body <- combine_class(
      "fill-width fill-height",
      class_body
    )
  }

  set_attr_call(shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    title = title,
    body = body,
    class = class,
    class_header = class_header,
    class_body = class_body,
    style_header = style_header,
    style_body = style_body,
    footer = footer,
    tools = tools,
    card_id = card_id,
    start_collapsed = start_collapsed,
    data_title = data_title
  ), call)
}

#' @rdname card
#' @export
card2 <- function(
  title, body_main, body_side = NULL,
  footer = NULL, tools = NULL, inputId = NULL,
  class = "", class_header = "", class_body = "min-height-400",
  class_foot = "",
  style_header = NULL, style_body = NULL, start_collapsed = FALSE,
  root_path = template_root()){

  call <- match.call()
  template_path <- file.path(root_path, 'views', 'card2.html')

  if(length(title) >= 1){
    data_title <- trimws(as.character(title[[1]])[[1]])
  } else {
    data_title <- ""
  }

  if(length(footer)){
    footer <- shiny::div(
      class = combine_class("card-footer", class_foot),
      footer
    )
  } else {
    footer <- ''
  }

  if(length(tools)){
    tools <- shiny::tagList(
      tools
    )
  } else {
    tools <- ""
  }

  if(length(inputId) == 1){
    if(grepl("[\"']", inputId)){
      stop("`card` ID cannot contain quotation marks.")
    }
    card_id <- sprintf(" id='%s'", inputId)
  } else {
    card_id <- ''
  }

  set_attr_call(shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    title = title,
    body_main = body_main,
    body_side = body_side,
    class = class,
    class_header = class_header,
    class_body = class_body,
    style_header = style_header,
    style_body = style_body,
    footer = footer,
    tools = tools,
    card_id = card_id,
    start_collapsed = start_collapsed,
    data_title = data_title
  ), call)
}

#' @rdname card
#' @export
card2_open <- function(inputId, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage(
    "shidashi.card2widget",
    list(
      selector = sprintf("#%s:not(.direct-chat-contacts-open) .card-tools>.btn-tool.card2-switch", session$ns(inputId))
    )
  )
}

#' @rdname card
#' @export
card2_close <- function(inputId, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage(
    "shidashi.card2widget",
    list(
      selector = sprintf("#%s.direct-chat-contacts-open .card-tools>.btn-tool.card2-switch", session$ns(inputId))
    )
  )
}

#' @rdname card
#' @export
card2_toggle <- function(inputId, session = shiny::getDefaultReactiveDomain()){
  # session$sendCustomMessage(
  #   "shidashi.click",
  #   list(
  #     selector = sprintf("#%s .card-tools>.btn-tool.card2-switch", session$ns(inputId))
  #   )
  # )
  session$sendCustomMessage(
    "shidashi.card2widget",
    list(
      selector = sprintf("#%s .card-tools>.btn-tool.card2-switch", session$ns(inputId))
    )
  )
}

#' @rdname card
#' @export
card_operate <- function(
  inputId, title, method, session = shiny::getDefaultReactiveDomain()
){
  method <- match.arg(
    method, choices = c("collapse", "expand", "remove", "toggle",
                        "maximize", "minimize", "toggleMaximize")
  )
  params <- list(method = method)
  if(missing(inputId)){
    params$title <- title
  } else {
    params$inputId <- session$ns(inputId)
  }
  session$sendCustomMessage("shidashi.cardwidget", params)
}


card_tabset_header <- function(id_tabset, index, title, active = FALSE){
  shiny::tags$li(
    class = "nav-item nav-tab-header",
    shiny::a(
      class = ifelse(active, "nav-link active", "nav-link"),
      id = sprintf("%s-%s-tab", id_tabset, index),
      'data-toggle' = "pill",
      href = sprintf("#%s-%s", id_tabset, index),
      role = "tab",
      "aria-controls" = sprintf("%s-%s", id_tabset, index),
      "aria-selected" = ifelse(active, "true", "false"),
      "tab-index" = index,
      title
    )
  )
}

card_tabset_content <- function(id_tabset, index, active, ...){
  shiny::div(
    class = ifelse(active, "tab-pane fade active fill-min-height show position-relative", "tab-pane fade fill-min-height position-relative"),
    id = sprintf("%s-%s", id_tabset, index),
    role = "tabpanel",
    "aria-labelledby" = sprintf("%s-%s-tab", id_tabset, index),
    "tab-index" = index,
    ...
  )
}

#' @title Generates a set of card panels
#' @description To insert, remove, or active card panels, see
#' \code{\link{card_tabset_operate}}.
#' @param ... 'HTML' tags; each tag will be placed into a card
#' @param names title of the tabs
#' @param inputId the id of the card-set
#' @param title the title of the card-set
#' @param active the title that will be active on load
#' @param tools a list of tools or badges generated by
#' \code{\link{card_tool}} or \code{\link{as_badge}}
#' @param footer the footer element of the card-set
#' @param class the 'HTML' class the of card-set
#' @param class_header,class_body,class_foot additional 'HTML'
#' class the of card header, body, and footer accordingly
#' @return 'HTML' tags
#' @seealso \code{\link{card_tabset_operate}}
#' @examples
#'
#' library(shiny)
#' library(shidashi)
#'
#' # Fake session to operate on card_tabset without shiny
#' session <- MockShinySession$new()
#'
#' card_tabset(
#'   inputId = "card_set",
#'   title = "Cardset with Tools",
#'   `Tab 1` = p("Tab content 1"),
#'   class_body = "height-500",
#'   tools = list(
#'     as_badge(
#'       "New|badge-success"
#'     ),
#'     card_tool(
#'       widget = "collapse"
#'     ),
#'     card_tool(
#'       widget = "maximize"
#'     )
#'   )
#' )
#'
#' card_tabset_insert(
#'   inputId = "card_set",
#'   title = "Tab 2",
#'   p("New content"),
#'   session = session
#' )
#'
#' card_tabset_activate(
#'   inputId = "card_set",
#'   title = "Tab 1",
#'   session = session
#' )
#'
#' card_tabset_remove(
#'   inputId = "card_set",
#'   title = "Tab 2",
#'   session = session
#' )
#'
#'
#'
#' @export
card_tabset <- function(
  ..., inputId = rand_string(), title = NULL,
  names = NULL, active = NULL, tools = NULL, footer = NULL,
  class = "", class_header = "", class_body = "", class_foot = ""){

  call_ <- match.call()

  if(grepl("[^a-zA-Z0-9_-]", inputId)){
    stop("card_tabset: invalid `inputId`, can only have letters, digits, '-', or '_'.")
  }

  tabs <- list(...)
  ntabs <- length(tabs)
  if(!length(names)){
    names <- names(tabs)
  }
  if(length(names) != ntabs){
    stop("card_tabset: `names` must have the same length as tab elements")
  }

  if(length(title) >= 1){
    data_title <- trimws(as.character(title[[1]])[[1]])
  } else {
    data_title <- ""
  }

  if(length(title) == 1){
    title <- shiny::tags$li(
      class="pt-2 px-3",
      shiny::h4(class="card-title", title)
    )
  }
  if(length(active)){
    active <- active[[1]]
  } else if(length(names)){
    active <- names[[1]]
  }

  if(length(tools)){
    tools <- shiny::tags$li(class = "nav-item ml-auto",
                            shiny::div(class = "card-tools",
                                       tools))
  }

  if(!is.null(footer)){
    footer <- shiny::div(
      class = combine_class("card-footer", class_foot),
      footer
    )
  }

  set_attr_call(shiny::div(
    class = sprintf("card card-tabs %s", class),
    `data-title` = data_title,
    shiny::div(
      class = sprintf("card-header p-0 pt-1 %s", class_header),
      shiny::tags$ul(
        class = "nav nav-tabs",
        id = inputId,
        role = "tablist",
        title,
        lapply(seq_len(ntabs), function(ii) {
          title <- names[[ii]]
          card_tabset_header(inputId, ii, title, active = title %in% active)
        }),
        tools
      )
    ),
    shiny::div(
      class = combine_class("card-body", class_body),
      shiny::div(
        class = "tab-content",
        id = sprintf("%sContent", inputId),
        lapply(seq_len(ntabs), function(ii) {
          title <- names[[ii]]
          card_tabset_content(inputId, ii, active = title %in% active, tabs[[ii]])
        })
      )
    ),
    footer
  ), call = call_)
}

#' @name card_tabset_operate
#' @title Add, active, or remove a card within \code{\link{card_tabset}}
#' @param inputId the element id of \code{\link{card_tabset}}
#' @param title the title of the card to insert, activate, or to remove
#' @param ... the content of the card
#' @param active whether to set the card to be active once added
#' @param notify_on_failure whether to show notifications on failure
#' @param session shiny session domain
#' @return These functions execute \code{session$sendCustomMessage} and return
#' whatever value generated by that function; usually nothing.
#' @seealso \code{\link{card_tabset}}
#' @export
card_tabset_insert <- function(inputId, title, ..., active = TRUE,
                            notify_on_failure = TRUE, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage(
    "shidashi.card_tabset_insert",
    list(
      inputId = session$ns(inputId),
      title = title,
      body = as.character(shiny::tagList(...)),
      active = isTRUE(active),
      notify_on_failure = isTRUE(notify_on_failure)
    )
  )
}

#' @rdname card_tabset_operate
#' @export
card_tabset_remove <- function(inputId, title, notify_on_failure = TRUE, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage(
    "shidashi.card_tabset_remove",
    list(
      inputId = session$ns(inputId),
      title = title,
      notify_on_failure = isTRUE(notify_on_failure)
    )
  )
}

#' @rdname card_tabset_operate
#' @export
card_tabset_activate <- function(inputId, title, notify_on_failure = TRUE, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage(
    "shidashi.card_tabset_activate",
    list(
      inputId = session$ns(inputId),
      title = title,
      notify_on_failure = isTRUE(notify_on_failure)
    )
  )
}

#' @title Generates small icon widgets
#' @description The icons cane be displayed at header line within
#' \code{\link{accordion}}, \code{\link{card}}, \code{\link{card2}},
#' \code{\link{card_tabset}}. See their examples.
#' @param inputId the button id, only necessary when \code{widget}
#' is \code{"custom"}
#' @param title the tip message to show when the mouse cursor hovers
#' on the icon
#' @param widget the icon widget type; choices are \code{"maximize"},
#' \code{"collapse"}, \code{"remove"}, \code{"flip"},
#' \code{"refresh"}, \code{"link"}, and \code{"custom"}; see 'Details'
#' @param icon icon to use if you are unsatisfied with the default ones
#' @param class additional class for the tool icons
#' @param href,target used when \code{widget} is \code{"link"}, will
#' open an external website; default is open a new tab
#' @param start_collapsed used when \code{widget} is \code{"collapse"},
#' whether the card should start collapsed
#' @param ... passed to the tag as attributes
#' @return 'HTML' tags to be included in \code{tools} parameter in
#' \code{\link{accordion}}, \code{\link{card}}, \code{\link{card2}},
#' \code{\link{card_tabset}}
#' @details There are 7 \code{widget} types:
#' \describe{
#' \item{\code{"maximize"}}{allow the elements to maximize
#' themselves to full-screen}
#' \item{\code{"collapse"}}{allow the elements to collapse}
#' \item{\code{"remove"}}{remove a \code{\link{card}} or
#' \code{\link{card2}}}
#' \item{\code{"flip"}}{used together with \code{\link{flip_box}},
#' to allow card body to flip over}
#' \item{\code{"refresh"}}{refresh all shiny outputs}
#' \item{\code{"link"}}{open a hyper-link pointing to external
#' websites}
#' \item{\code{"custom"}}{turn the icon into a \code{actionButton}.
#' in this case, \code{inputId} must be specified.}
#' }
#' @export
card_tool <- function(inputId = NULL, title = NULL, widget = c("maximize", "collapse", "remove", "flip", "refresh", "link", "custom"), icon, class = "", href = "#", target = "_blank", start_collapsed = FALSE, ...){
  widget <- match.arg(widget)

  if(missing(icon)){
    icon <- switch (
      widget,
      maximize = as_icon("expand"),
      collapse = as_icon(ifelse(start_collapsed, "plus", "minus")),
      remove = as_icon("times"),
      refresh = as_icon("sync-alt"),
      link = as_icon("external-link-alt"),
      flip = as_icon('adjust'),
      {
        stop("Custom widget must provide a valid icon; see ?shiny::icon")
      }
    )
  } else {
    icon <- as_icon(icon)
  }

  if(length(inputId) == 1){
    class <- combine_class("btn btn-tool action-button", class)
  } else {
    class <- combine_class("btn btn-tool", class)
  }

  if( widget == "custom" ){
    widget <- NULL
  }

  if(startsWith(href, "#")){
    target <- "_self"
  }

  return(shiny::a(
    id = inputId,
    type="button",
    href = href,
    target = target,
    class=class,
    `data-card-widget` = widget,
    title = title,
    icon,
    ...
  ))

}

#' @title Generates outputs that can be written to clipboards with one click
#' @param outputId the output id
#' @param message tool tip to show when mouse hovers on the element
#' @param clip_text the initial text to copy to clipboards
#' @param class 'HTML' class of the element
#' @param as_card_tool whether to make the output as \code{\link{card_tool}}
#' @param expr expression to evaluate; the results will replace
#' \code{clip_text}
#' @param env environment to evaluate \code{expr}
#' @param quoted whether \code{expr} is quoted
#' @param outputArgs used to replace default arguments of \code{clipboardOutput}
#' @return 'HTML' elements that can write to clip-board once users click on
#' them.
#' @examples
#' clipboardOutput(clip_text = "Hey there")
#'
#' @export
clipboardOutput <- function(
  outputId = rand_string(), message = "Copy to clipboard",
  clip_text = "", class = NULL, as_card_tool = FALSE){

  if(as_card_tool){
    card_tool(
      class = combine_class('clipboard-btn', "shidashi-clipboard-output", class),
      icon = "copy",
      title = message,
      inputId = outputId,
      widget = "custom",
      "data-clipboard-text" = clip_text
    )
  } else {
    shiny::div(
      id = outputId,
      class = "shidashi-clipboard-output",
      shiny::tags$button(
        class = combine_class('clipboard-btn btn btn-default', class),
        "data-clipboard-text" = clip_text,
        role = 'button',
        message
      )
    )
  }

}

#' @rdname clipboardOutput
#' @export
renderClipboard <- function(expr, env=parent.frame(), quoted=FALSE, outputArgs = list()) {

  func <- shiny::installExprFunction(expr, "func", env, quoted, label = "renderClipboard")
  shiny::createRenderFunction(func, function(value, session, name, ...) {

    if(!is.character(value)) {
      value <- deparse(value)
    }
    if(length(value) > 1){
      value <- paste(value, collapse = "\n")
    }
    value

  }, clipboardOutput, outputArgs)

}



#' Generates 'HTML' info box
#' @param ... box content
#' @param icon the box icon; default is \code{"envelope"}, can be hidden by
#' specifying \code{NULL}
#' @param class class of the box container
#' @param class_icon class of the icon
#' @param class_content class of the box body
#' @param root_path see \code{\link{template_root}}
#' @return 'HTML' tags
#' @examples
#'
#' library(shiny)
#' library(shidashi)
#'
#' info_box("Message", icon = "cogs")
#'
#' info_box(
#'   icon = "thumbs-up",
#'   span(class = "info-box-text", "Likes"),
#'   span(class = "info-box-number", "12,320"),
#'   class_icon = "bg-red"
#' )
#'
#' info_box("No icons", icon = NULL)
#'
#' @export
info_box <- function(..., icon = "envelope", class = "",
                     class_icon = "bg-info", class_content = "",
                     root_path = template_root()) {
  call <- match.call(expand.dots = TRUE)
  if(length(icon)){
    icon <- shiny::span(
      class = combine_class("info-box-icon", class_icon),
      as_icon(icon)
    )
  }

  template_path <- file.path(root_path, 'views', 'info-box.html')

  re <- shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    icon = icon,
    body = shiny::tagList(...),
    class = combine_class(class),
    class_content = combine_class(class_content)
  )

  set_attr_call(re, call)
}

#' @title An 'HTML' container that can flip
#' @param inputId element 'HTML' id; must be specified if \code{active_on} is
#' not \code{'click'}
#' @param front 'HTML' elements to show in the front
#' @param back 'HTML' elements to show when the box is flipped
#' @param active_on the condition when a box should be flipped; choices are
#' \code{'click'}: flip when double-click on both sides; \code{'click-front'}:
#' only flip when the front face is double-clicked; \code{'manual'}: manually
#' flip in \code{R} code (see \code{{flip(inputId)}} function)
#' @param session shiny session; default is current active domain
#' @param class 'HTML' class
#' @return \code{flip_box} returns 'HTML' tags; \code{flip} should be called
#' from shiny session, and returns nothing
#' @examples
#'
#' # More examples are available in demo
#'
#' library(shiny)
#' library(shidashi)
#'
#' session <- MockShinySession$new()
#'
#' flip_box(front = info_box("Side A"),
#'          back = info_box("Side B"),
#'          inputId = 'flip_box1')
#'
#' flip('flip_box1', session = session)
#'
#' @export
flip_box <- function(front, back, active_on = c("click", "click-front", "manual"), inputId = NULL, class = NULL){
  call <- match.call()
  active_on <- match.arg(active_on)
  if(active_on != 'click' && length(inputId) != 1){
    stop("`inputId` must be specified if `active_on` is not 'click'")
  }
  set_attr_call(shiny::div(
    class = combine_class("flip-box", class),
    "data-toggle" = active_on,
    id = inputId,
    shiny::div(
      class = "flip-box-inner",
      shiny::div(
        class = "flip-box-back",
        back
      ),
      shiny::div(
        class = "flip-box-front",
        front
      )
    )
  ), call)
}

#' @rdname flip_box
#' @export
flip <- function(inputId, session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage("shidashi.box_flip", list(
    inputId = session$ns(inputId)
  ))
}


#' Convert characters, shiny icons into 'fontawesome' 4
#' @param icon character or \code{\link[shiny]{icon}}
#' @param class icon class; change this when you are using 'fontawesome'
#' professional version. The choices are \code{'fa'} (compatible),
#' \code{'fas'} (strong), \code{'far'} (regular), \code{'fal'} (light),
#' and \code{'fad'} (duo-tone).
#' @return 'HTML' tag
#' @examples
#'
#' if(interactive()){
#' as_icon("bookmark", class = "far")
#' as_icon("bookmark", class = "fas")
#'
#' # no icon
#' as_icon(NULL)
#' }
#'
#' @export
as_icon <- function(icon = NULL, class = "fas"){
  class <- combine_class(class)

  if(!length(icon) || (is.character(icon) && icon == "")){
    icon <- ""
  } else {
    if(inherits(icon, "shiny.tag")) {
      icon$attribs$class <- combine_class(icon$attribs$class, class)
    } else {
      icon <- shiny::icon(icon, class = class)
    }
    # remove class fa
    if ( !"fa" %in% class ){
      icon$attribs$class <- remove_html_class(icon$attribs$class, "fa")
    }
  }


  icon
}

#' @title Generates badge icons
#' @description Usually used along with \code{\link{card}},
#' \code{\link{card2}}, and \code{\link{card_tabset}}. See \code{tools}
#' parameters in these functions accordingly.
#' @param badge characters, \code{"shiny.tag"} object or \code{NULL}
#' @return 'HTML' tags
#' @details When \code{badge} is \code{NULL} or empty, then \code{as_badge}
#' returns empty strings. When \code{badge} is a \code{"shiny.tag"} object,
#' then 'HTML' class \code{'right'} and \code{'badge'} will be appended.
#' When \code{badge} is a string, it should follow the syntax of
#' \code{"message|class"}. The text before \code{"|"} will be the badge
#' message, and the text after the \code{"|"} becomes the class string.
#' @examples
#'
#' # Basic usage
#' as_badge("New")
#'
#' # Add class `bg-red` and `no-padding`
#' as_badge("New|bg-red no-padding")
#'
#'
#' @export
as_badge <- function(badge = NULL){
  if(!length(badge) || nchar(badge) == 0){
    badge <- ''
  } else {
    if(inherits(badge, "shiny.tag")) {
      badge$attribs$class <- combine_class(badge$attribs$class, "right badge")
    } else {
      badge <- strsplit(badge, "\\|")[[1]]
      if(length(badge) > 1){
        badge <- shiny::span(class=paste("right badge", badge[[2]]), badge[[1]])
      } else {
        badge <- shiny::span(class=paste("right badge"), badge[[1]])
      }
    }
  }
  badge
}

menu_item <- function(
  text, href = "#", icon = NULL, active = FALSE, badge = NULL,
  target = "_blank", root_path = template_root()){

  icon <- as_icon(icon, class = "nav-icon fas")
  badge <- as_badge(badge)
  module <- ''
  if(startsWith(href, "#")){
    target <- "_self"
  } else if (startsWith(href, "?module=")) {
    query_list <- httr::parse_url(href)
    query_list$query
    module <- query_list$query$module
    module <- gsub(pattern = " ", replacement = "", module)
    if( grepl("[^a-zA-Z0-9_]", module) ){
      stop("Function `menu_item`: for `href` with module link (starts with '?module=<ID>'), the module `ID` can only contain letters, digits, and/or '_'.")
    }
  }
  template_path <- file.path(root_path, "views", "menu-item.html")
  # if(!file.exists(template_path)){
  #   template_path <- system.file('snippets', 'menu-item.html', package = 'shidashi')
  # }
  shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    text = text, href = shiny::HTML(href), icon = icon, badge = badge, active = active,
    target = target, module = module)
}

menu_item_dropdown <- function(
  text, ..., .list = NULL, icon = NULL, active = FALSE,
  badge = NULL, root_path = template_root()){

  sub_items <- c(shiny::tagList(...), .list)
  icon <- as_icon(icon, class = "nav-icon fas")
  badge <- as_badge(badge)
  template_path <- file.path(root_path, "views", "menu-item-dropdown.html")
  # if(!file.exists(template_path)){
  #   template_path <- system.file('snippets', 'menu-item-dropdown.html', package = 'shidashi')
  # }
  shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    text = text, icon = icon, badge = badge,
    active = active, sub_items = sub_items)
}

#' @title Obtain the module information
#' @param root_path the root path of the website project
#' @param settings_file the settings file containing the module information
#' @param request 'HTTP' request string
#' @param env environment to load module variables into
#' @return A data frame with the following columns that contain the module
#' information:
#' \describe{
#' \item{\code{id}}{module id, folder name}
#' \item{\code{order}}{display order in side-bar}
#' \item{\code{group}}{group menu name if applicable, otherwise \code{NA}}
#' \item{\code{label}}{the readable label to be displayed on the side-bar}
#' \item{\code{icon}}{icon that will be displayed ahead of label, will be
#' passed to \code{\link{as_icon}}}
#' \item{\code{badge}}{badge text that will be displayed
#' following the module label, will be passed to \code{\link{as_badge}}}
#' \item{\code{url}}{the relative 'URL' address of the module.}
#' }
#' @details The module files are stored in \code{modules/} folder in your
#' project. The folder names are the module id. Within each folder,
#' there should be one \code{"server.R"}, \code{R/}, and a
#' \code{"module-ui.html"}.
#'
#' The \code{R/} folder stores R code files that generate variables,
#' which will be available to the other two files. These variables, along
#' with some built-ins, will be used to render \code{"module-ui.html"}.
#' The built-in functions are
#' \describe{
#' \item{ns}{shiny name-space function; should be used to generate the id for
#' inputs and outputs. This strategy avoids conflict id effectively.}
#' \item{.module_id}{a variable of the module id}
#' \item{module_title}{a function that returns the module label}
#' }
#'
#' The \code{"server.R"} has access to all the code in \code{R/} as well.
#' Therefore it is highly recommended that you write each 'UI' component
#' side-by-side with their corresponding server functions and call
#' these server functions in \code{"server.R"}.
#'
#' @examples
#'
#' library(shiny)
#' module_info()
#'
#' # load master module
#' load_module()
#'
#' # load specific module
#' module_data <- load_module(
#'   request = list(QUERY_STRING = "/?module=module_id"))
#' env <- module_data$environment
#'
#' if(interactive()){
#'
#' # get module title
#' env$module_title()
#'
#' # generate module-specific shiny id
#' env$ns("input1")
#'
#' # generate part of the UI
#' env$ui()
#'
#' }
#'
#' @export
module_info <- function(root_path = template_root(),
                        settings_file = "modules.yaml"){
  settings <- yaml::read_yaml(file.path(root_path, settings_file))
  # settings <- yaml::read_yaml('modules.yaml')
  groups <- names(settings$groups)
  groups <- groups[groups != ""]

  modules <- settings$modules
  modules_ids <- names(settings$modules)

  groups <- unique(groups)
  group_level <- factor(groups, levels = groups, ordered = TRUE)

  module_tbl <- do.call('rbind', lapply(modules_ids, function(mid){
    x <- modules[[mid]]
    y <- x[!names(x) %in% c('order', 'group', 'label', 'icon', 'badge', 'module', 'hidden')]
    y$module <- mid
    url <- httr::modify_url("?module=", query = y)
    if(length(x$group) == 1 && x$group %in% group_level){
      x$group <- group_level[group_level == x$group][[1]]
    } else {
      x$group <- NA
    }
    data.frame(
      id = mid,
      group = x$group,
      label = ifelse(length(x$label) == 1, x$label, ""),
      icon = ifelse(length(x$icon) == 1, x$icon, ""),
      badge = ifelse(length(x$badge) == 1, x$badge, ""),
      url = gsub("^[^\\?]+", "/", url),
      stringsAsFactors = FALSE
    )
  }))
  module_tbl
}


load_module_resource <- function(root_path = template_root(), module_id = NULL, env = parent.frame()){
  root_path <- normalizePath(root_path, mustWork = TRUE)

  re <- list(
    environment = env,
    has_module = FALSE,
    root_path = root_path,
    template_path = file.path(root_path, "index.html")
  )

  module_info <- list(
    id = module_id,
    server = function(input, output, session, ...){},
    template_path = NULL
  )

  r_folder <- file.path(root_path, "R")
  if(dir.exists(r_folder)){
    fs <- list.files(r_folder, pattern = "\\.R$", ignore.case = TRUE,
                     recursive = FALSE, include.dirs = FALSE,
                     no.. = TRUE, all.files = TRUE, full.names = TRUE)
    for(f in fs){
      source(f, local = env)
    }
  }

  if(length(module_id)){
    if(length(module_id) > 1){
      stop("length of `module_id` must not exceed one.")
    }
    module_root <- file.path(root_path, 'modules', module_id)
    module_info$template_path <- file.path(module_root, "module-ui.html")

    if(dir.exists(module_root)){

      re$has_module <- TRUE
      env$ns <- shiny::NS(module_id)
      env$.module_id <- module_id
      env$module_title <- function(){
        modules <- module_info()
        modules$label[modules$id == module_id]
      }

      r_folder <- file.path(module_root, 'R')
      if(dir.exists(r_folder)){
        fs <- list.files(r_folder, pattern = "\\.R$", ignore.case = TRUE,
                         recursive = FALSE, include.dirs = FALSE,
                         no.. = TRUE, all.files = TRUE, full.names = TRUE)
        for(f in fs){
          source(f, local = env)
        }
      }

      module_handler <- file.path(root_path, 'modules', module_id, 'server.R')
      if(file.exists(module_handler)){
        # server_env <- new.env(parent = env)
        server_env <- env
        server_source <- source(module_handler, local = server_env)

        server_function <- server_source$value
        if(!is.function(server_function)){
          server_function <- server_env$server
        }

        if(!is.function(server_function)){
          stop("Module `", module_id, "` has server.R, but cannot detect server function.")
        }
        module_info$server <- server_function
      }

      # make sure `ns` and `.module_id` are consistent
      env$ns <- shiny::NS(module_id)
      env$.module_id <- module_id

    }
  }

  re$module <- module_info
  re
}

#' @rdname module_info
#' @export
load_module <- function(
  root_path = template_root(),
  request = list(QUERY_STRING = "/"),
  env = parent.frame()){

  force(env)
  query_str <- request$QUERY_STRING
  if(length(query_str) != 1) {
    query_str <- '/'
  }
  query_list <- httr::parse_url(query_str)
  module_id <- query_list$query$module
  shared_id <- query_list$query$shared_id
  shared_id <- tolower(shared_id)
  shared_id <- gsub("[^a-z0-9_]", "", shared_id)
  if(length(shared_id) != 1 || nchar(shared_id) ){
    shared_id <- rand_string(26)
  }

  env$.request <- request
  env$.shared_id <- shared_id
  load_module_resource(root_path, module_id, env)
}


#' @name notification
#' @title The 'Bootstrap' notification
#' @param message notification body content, can be 'HTML' tags
#' @param title,subtitle title and subtitle of the notification
#' @param type type of the notification; can be \code{"default"},
#' \code{"info"}, \code{"warning"}, \code{"success"}, \code{"danger"},
#' \code{"white"}, \code{"dark"}
#' @param close whether to allow users to close the notification
#' @param position where the notification should be; choices are
#' \code{"topRight"}, \code{"topLeft"}, \code{"bottomRight"},
#' \code{"bottomLeft"}
#' @param autohide whether to automatically hide the notification
#' @param fixed whether the position should be fixed
#' @param delay integer in millisecond to hide the notification if
#' \code{autohide=TRUE}
#' @param icon the icon of the title
#' @param collapse if \code{message} is a character vector, the collapse string
#' @param session shiny session domain
#' @param class the extra class of the notification, can be used for style
#' purposes, or by \code{clear_notifications} to close specific notification
#' types.
#' @param ... other options; see
#' \url{https://adminlte.io/docs/3.1//javascript/toasts.html#options}
#'
#' @return Both functions should be used in shiny reactive contexts. The
#' messages will be sent to shiny 'JavaScript' interface and nothing will be
#' returned.
#' @examples
#' \dontrun{
#'
#' # the examples must run in shiny reactive context
#'
#' show_notification(
#'   message = "This validation process has finished. You are welcome to proceed.",
#'   autohide = FALSE,
#'   title = "Success!",
#'   subtitle = "type='success'",
#'   type = "success"
#' )
#'
#' show_notification(
#'   message = "This notification has title and subtitle",
#'   autohide = FALSE,
#'   title = "Hi there!",
#'   subtitle = "Welcome!",
#'   icon = "kiwi-bird",
#'   class = "notification-auto"
#' )
#'
#' # only clear notifications with class "notification-auto"
#' clear_notifications("notification-auto")
#'
#' }
NULL

#' @rdname notification
#' @export
show_notification <- function(
  message,
  title = "Notification!",
  subtitle = "",
  type = c("default", "info", "warning", "success", "danger", "white", "dark"),
  close = TRUE,
  position = c("topRight", "topLeft", "bottomRight", "bottomLeft"),
  autohide = TRUE,
  fixed = TRUE,
  delay = 5000,
  icon = NULL,
  collapse = "",
  session = shiny::getDefaultReactiveDomain(),
  class = NULL,
  ...
){
  type <- match.arg(type)
  position <- match.arg(position)
  delay <- as.integer(delay)
  if(!length(delay) || is.na(delay) || delay <= 0){
    delay <- 5000L
    close <- TRUE
  }
  if(length(icon)){
    icon <- as_icon(icon)
    icon <- icon$attribs$class
  }

  message <- paste(message, collapse = "")


  session$sendCustomMessage("shidashi.show_notification", list(
    position = position,
    autohide = !isFALSE(autohide),
    delay = delay,
    icon = icon,
    title = title,
    subtitle = subtitle,
    close = !isFALSE(close),
    body = message,
    fixed = !isFALSE(fixed),
    class = combine_class(sprintf("bg-%s", type), class),
    ...
  ))
  invisible()
}

#' @rdname notification
#' @export
clear_notifications <- function(
  class = NULL,
  session = shiny::getDefaultReactiveDomain()){

  class <- unique(c(class, "toast"))
  class <- gsub(" ", "", class)
  class <- class[class != ""]
  selector <- paste0(".", class, collapse = "")
  session$sendCustomMessage("shidashi.clear_notification", list(
    selector = selector
  ))
  invisible()
}




#' @title Wrapper of shiny progress that can run without shiny
#' @param title the title of the progress
#' @param outputId the element id of \code{\link{progressOutput}}, or
#' \code{NULL} to use the default shiny progress
#' @param max max steps of the procedure
#' @param ... passed to initialization method of \code{\link[shiny]{Progress}}
#' @param quiet whether the progress needs to be quiet
#' @param session shiny session domain
#' @param shiny_auto_close whether to close the progress once function exits
#' @param log alternative log function
#' @return a list of functions that controls the progress
#' @examples
#'
#' {
#'   progress <- shiny_progress("Procedure A", max = 10)
#'   for(i in 1:10){
#'     progress$inc(sprintf("Step %s", i))
#'     Sys.sleep(0.1)
#'   }
#'   progress$close()
#'
#' }
#'
#' if(interactive()){
#'   library(shiny)
#'
#'   ui <- fluidPage(
#'     fluidRow(
#'       column(12, actionButton("click", "Click me"))
#'     )
#'   )
#'
#'   server <- function(input, output, session) {
#'     observeEvent(input$click, {
#'       progress <- shiny_progress("Procedure B", max = 10,
#'                                  shiny_auto_close = TRUE)
#'       for(i in 1:10){
#'         progress$inc(sprintf("Step %s", i))
#'         Sys.sleep(0.1)
#'       }
#'     })
#'   }
#'
#'   shinyApp(ui, server)
#' }
#'
#' @export
shiny_progress <- function (
  title, max = 1, ..., quiet = FALSE,
  session = shiny::getDefaultReactiveDomain(), shiny_auto_close = FALSE,
  log = NULL, outputId = NULL) {
  if (missing(title) || is.null(title)) {
    title <- ""
  }
  if (length(title) > 1) {
    title <- paste(title, collapse = "")
  }
  if (inherits(session, c("ShinySession", "session_proxy",
                          "R6"))) {
    within_shiny <- TRUE
  }
  else {
    within_shiny <- FALSE
  }
  current <- 0
  closed <- FALSE
  get_value <- function() {
    current
  }
  is_closed <- function() {
    closed
  }
  logger <- function(..., .quiet = quiet, level = "DEFAULT",
                     bullet = "play") {
    if (!.quiet) {
      if (is.function(log)) {
        log(...)
      }
      else {
        s <- paste(..., collapse = "", sep = "")
        nz <- nchar(s, allowNA = TRUE, keepNA = TRUE)
        w <- getOption("width", 80L)
        s <- paste0(s, paste(rep(' ', w - nz %% w), collapse = ""))
        message("\r", s, appendLF = identical(bullet, "stop"))
      }
    }
  }
  if (quiet || !within_shiny) {
    progress <- NULL
    logger(sprintf("[%s]: initializing...", title), level = "DEFAULT",
           bullet = "play")
    inc <- function(detail, message = NULL, amount = 1, ...) {
      stopifnot(!closed)
      quiet <- c(list(...)[["quiet"]], quiet)[[1]]
      if (!is.null(message) && length(message) == 1) {
        title <<- message
      }
      current <<- amount + current
      logger(sprintf("[%s]: %s (%d out of %d)", title,
                     detail, current, max), level = "DEFAULT", bullet = "arrow_right",
             .quiet = quiet)
    }
    close <- function(message = "Finished") {
      closed <<- TRUE
      logger(message, level = "DEFAULT", bullet = "stop")
    }
    reset <- function(detail = "", message = "", value = 0) {
      title <<- message
      current <<- value
    }
  }
  else if(length(outputId)){
    progress <- NULL
    inc <- function(detail, message = NULL, amount = 1, ...) {
      current <<- current + amount
      if(length(message)){ title <<- message[[1]] }
      session$sendCustomMessage("shidashi.set_progress", list(
        outputId = session$ns(outputId),
        value = current,
        max = max,
        description = paste(title, detail, sep = " - ")[[1]]
      ))
    }
    close <- function(message = "Finished") {
      closed <<- TRUE
      session$sendCustomMessage("shidashi.set_progress", list(
        outputId = outputId,
        value = max,
        max = max,
        description = message
      ))
    }
    reset <- function(detail = "", message = "", value = 0) {
      if(length(message)){
        title <<- message[[1]]
      } else {
        title <<- ""
      }
      if(length(detail)){
        detail <- paste(title, detail, sep = " - ")[[1]]
      } else {
        detail <- message
      }
      current <<- value
      session$sendCustomMessage("shidashi.set_progress", list(
        outputId = outputId,
        value = current,
        max = max,
        description = detail
      ))
    }
  } else {
    progress <- shiny::Progress$new(session = session, max = max,
                                    ...)
    inc <- function(detail, message = NULL, amount = 1, ...) {
      if (!is.null(message) && length(message) == 1) {
        title <<- message
      }
      progress$inc(detail = detail, message = title, amount = amount)
    }
    close <- function(message = "Finished") {
      if (!closed) {
        progress$close()
        closed <<- TRUE
      }
    }
    reset <- function(detail = "", message = "", value = 0) {
      title <<- message
      current <<- value
      progress$set(value = value, message = title, detail = detail)
    }
    if (shiny_auto_close) {
      parent_frame <- parent.frame()
      do.call(on.exit, list(substitute(close()), add = TRUE),
              envir = parent_frame)
    }
    inc(detail = "Initializing...", amount = 0)
  }
  return(list(.progress = progress, inc = inc, close = close,
              reset = reset, get_value = get_value, is_closed = is_closed))
}

#' Progress bar in shiny dashboard
#' @description For detailed usage, see demo application by
#' running \code{render()}.
#' @param outputId the element id of the progress
#' @param expr R expression that should return a named list of \code{value} and
#' \code{description}
#' @param env where to evaluate \code{expr}
#' @param quoted whether \code{expr} is quoted
#' @param outputArgs a list of other parameters in \code{progressOutput}
#' @param ... extra elements on the top of the progress bar
#' @param description descriptive message below the progress bar
#' @param width width of the progress
#' @param class progress class, default is \code{"bg-primary"}
#' @param value initial value, ranging from 0 to 100; default is 0
#' @param size size of the progress bar; choices are \code{"md"}, \code{"sm"},
#' \code{"xs"}
#' @return \code{progressOutput} returns 'HTML' tags containing progress bars
#' that can be rendered later via \code{\link{shiny_progress}} or
#' \code{renderProgress}. \code{renderProgress} returns shiny render functions
#' internally.
#' @examples
#'
#' library(shiny)
#' library(shidashi)
#' progressOutput("sales_report_prog1",
#'                description = "6 days left!",
#'                "Add Products to Cart",
#'                span(class="float-right", "123/150"),
#'                value = 123/150 * 100)
#'
#' # server function
#' server <- function(input, output, session, ...){
#'   output$sales_report_prog1 <- renderProgress({
#'     return(list(
#'       value = 140 / 150 * 100,
#'       description = "5 days left!"
#'     ))
#'   })
#' }
#'
#' @export
progressOutput <- function(
  outputId, ..., description = "Initializing",
  width = "100%", class = "bg-primary",
  value = 0, size = c("md", "sm", "xs")
){

  if(value < 0){
    value <- 0
  } else if(value > 100){
    value <- 100L
  }
  size <- match.arg(size)

  shiny::div(
    class = "shidashi-progress-output progress-group",
    id = outputId,
    style = sprintf("width: %s;", width),
    ...,
    shiny::div(
      class = sprintf("progress progress-%s", size),
      shiny::div(
        class = combine_class("progress-bar", class),
        style = sprintf("width: %.0f%%", value),
      )
    ),
    shiny::span(
      class = "progress-description progress-message",
      description
    ),
    shiny::span(
      class = "progress-description progress-error"
    )
  )

}

#' @rdname progressOutput
#' @export
renderProgress <- function(expr, env=parent.frame(), quoted=FALSE, outputArgs = list()) {

  func <- shiny::installExprFunction(expr, "func", env, quoted, label = "renderProgress")
  shiny::createRenderFunction(func, function(value, session, name, ...) {
    if(is.list(value)){
      description <- value$description
      value <- value$value
    } else {
      description <- NULL
    }
    if(!length(value)){
      value <- 0L
    } else {
      value <- as.integer(value)
    }

    if( value < 0L ){ value <- 0L }
    if( value > 100L ){ value <- 100L }
    list(
      value = value,
      description = description
    )

  }, progressOutput, outputArgs)

}



#' Render a 'shidashi' project
#' @param root_path the project path, default is the demo folder from
#' \code{template_root()}
#' @param ... additional parameters passed to \code{\link[shiny]{runApp}},
#' such as \code{host}, \code{port}
#' @param launch_browser whether to launch browser; default is \code{TRUE}
#' @param as_job whether to run as 'RStudio' jobs; this options is only
#' available when 'RStudio' is available
#' @param test_mode whether to test the project; this options is helpful when
#' you want to debug the project without relaunching shiny applications
#' @param prelaunch expression to execute before launching the session; the
#' expression will execute in a brand new session
#' @param prelaunch_quoted whether the expression is quoted; default is false
#' @return This functions runs a 'shiny' application, and returns the job id
#' if 'RStudio' is available.
#'
#' @examples
#'
#' template_root()
#'
#' if(interactive()){
#'   render()
#' }
#'
#' @export
render <- function(
  root_path = template_root(),
  ...,
  prelaunch = NULL,
  prelaunch_quoted = FALSE,
  launch_browser = TRUE,
  as_job = TRUE,
  test_mode = getOption("shiny.testmode", FALSE)
){
  if(!dir.exists(root_path)){
    stop("`root_path` cannot be found: ", root_path)
  }
  root_path <- normalizePath(root_path, mustWork = TRUE, winslash = "/")

  if(!prelaunch_quoted) {
    prelaunch <- substitute(prelaunch)
  }

  writeLines(
    c(
      sprintf("shidashi::template_settings$set('root_path' = '%s')", root_path),
      "shidashi::adminlte_ui()"
    ),
    file.path(root_path, "ui.R")
  )

  if(!as_job || system.file(package = 'rstudioapi') == '' ||
     !rstudioapi::isAvailable(version_needed = "1.4.1717",
                              child_ok = FALSE)){

    shidashi::template_settings$set('root_path' = root_path)
    shiny::runApp(appDir = root_path, launch.browser = launch_browser, test.mode = test_mode, ...)
  } else {
    script <- file.path(root_path, "_rs_job.R")
    args <- list(
      ...,
      launch.browser = launch_browser,
      test.mode = test_mode,
      appDir = root_path
    )
    call <- as.call(list(
      quote(shiny::runApp),
      ...,
      launch.browser = launch_browser,
      test.mode = test_mode,
      appDir = root_path
    ))
    s <- c(
      sprintf("shidashi::template_settings$set('root_path' = '%s')", root_path),
      'options("crayon.enabled" = TRUE)',
      'options("crayon.colors" = 256)\n',
      deparse(prelaunch),
      '\n'
    )
    s <- c(s, deparse(call))
    writeLines(
      con = script,
      s
    )
    rstudioapi::jobRunScript(
      path = script, workingDir = root_path,
      name = basename(root_path)
    )
  }

}

#' Template function to include 'snippets' in the view folder
#' @description Store the reusing 'HTML' segments in the
#' \code{views} folder. This function should be used in the
#' \code{'index.html'} template
#' @param file files in the template \code{views} folder
#' @param ... ignored
#' @param .env,.root_path internally used
#' @return rendered 'HTML' segments
#' @examples
#' \dontrun{
#' # in your 'index.html' file
#' <html>
#' <header>
#' {{ shidashi::include_view("header.html") }}
#' </header>
#' <body>
#'
#' </body>
#' <!-- Before closing html tag -->
#' {{ shidashi::include_view("footer.html") }}
#' </html>
#' }
#' @export
include_view <- function(file, ..., .env = parent.frame(),
                         .root_path = template_root()){
  tryCatch({
    file <- normalizePath(file.path(.root_path, 'views', file),
                          mustWork = TRUE)
  }, error = function(e){
    stop(call. = NULL, "Cannot find views/", file)
  })
  list2env(list(.env = .env), envir=.GlobalEnv)
  args <- NULL
  if(is.environment(.env$env)) {
    args <- get0("@args", envir = .env$env, ifnotfound = NULL)
  }
  if(!is.list(args)) {
    args <- as.list(.env)
  }
  # more_args <- list(...)
  # for(nm in names(more_args)){
  #   if(nm != ""){
  #     args[[nm]] <- more_args[[nm]]
  #   }
  # }
  argnames <- names(args)
  args <- args[!argnames %in% c("headContent", "suppressDependencies", "filename", "document_", "text_")]
  call <- as.call(c(
    list(quote(shiny::htmlTemplate),
         filename = file,
         document_ = FALSE),
    args
  ))
  return(eval(call, envir = .env))
  # shiny::htmlTemplate(file, ..., document_ = FALSE)
}

#' Reset shiny outputs with messages
#' @description Forces outdated output to reset and show a silent message.
#' @param outputId output ID
#' @param message output message
#' @param session shiny reactive domain
#' @return No value
#' @export
reset_output <- function(outputId, message = "This output has been reset",
                         session = shiny::getDefaultReactiveDomain()) {
  session$sendCustomMessage("shidashi.reset_output", list(
    outputId = session$ns(outputId),
    message = message
  ))
}

#' @title Download 'shidashi' templates from 'Github'
#' @param path the path to create 'shidashi' project
#' @param user 'Github' user name
#' @param theme the theme to download
#' @param repo repository if the name is other than \code{'shidashi-templates'}
#' @param branch branch name if other than \code{'main'} or \code{'master'}
#' @param ... ignored
#' @return the target project path
#' @details To publish a 'shidashi' template, create a 'Github' repository
#' called \code{'shidashi-templates'}, or fork the \href{https://github.com/dipterix/shidashi-templates}{built-in templates}. The \code{theme} is the sub-folder
#' of the template repository.
#'
#' An easy way to use a template in your project is through the 'RStudio'
#' project widget. In the 'RStudio' navigation bar, go to "File" menu,
#' click on the "New Project..." button, select the "Create a new project"
#' option, and find the item that creates 'shidashi' templates. Use the
#' widget to set up template directory.
#'
#' @export
use_template <- function(
  path, user = "dipterix", theme = "AdminLTE3",
  repo = "shidashi-templates", branch = "main", ...
){

  # ensure path exists
  dir.create(path, recursive = TRUE, showWarnings = FALSE)

  # Download template
  temppath <- tempfile()
  tempzip <- paste0(temppath, ".zip")
  if(file.exists(tempzip)){
    unlink(tempzip)
  }
  if(dir.exists(temppath)){
    unlink(temppath, recursive = TRUE, force = TRUE)
  }
  old <- options()
  on.exit({
    options(old)
    unlink(tempzip)
    unlink(temppath, recursive = TRUE, force = TRUE)
  })

  options(timeout = 10000)

  url <- sprintf("https://github.com/%s/%s/archive/%s.zip", user, repo, branch)
  if(branch %in% c("main", "master")){
    tryCatch({
      suppressWarnings({
        utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
      })
    }, error = function(e){
      old_branch <- branch
      if(branch == "main"){
        branch <<- "master"
      } else {
        branch <<- "main"
      }
      message("Branch `", old_branch, "` does not have zip file, switching to `", branch, "`.", appendLF = TRUE)
      url <- sprintf("https://github.com/%s/%s/archive/%s.zip", user, repo, branch)
      utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
    })

  } else {
    utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
  }


  # url <- "https://github.com/dipterix/shidashi-templates/archive/refs/heads/master.zip"
  # utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
  utils::unzip(tempzip, exdir = temppath)

  folder_name <- sprintf("%s-%s", repo, branch)
  root <- file.path(temppath, folder_name)
  if(!dir.exists(root)){
    stop("Cannot find branch folder `", folder_name, "`. Please report this issue to \n\thttps://github.com/dipterix/shidashi/issues")
  }
  project_dir <- normalizePath(file.path(root, theme), mustWork = TRUE)

  fs <- list.files(project_dir, all.files = FALSE, recursive = FALSE, full.names = TRUE, include.dirs = TRUE, no.. = TRUE)

  if(!length(fs)){
    if(theme == ""){
      stop("Empty sub-module repository. Your theme contains no file. Abort.")
    }
    # This could be a sub-module, parse .gitmodules
    submodule_spath <- file.path(root, ".gitmodules")
    if(!file.exists(submodule_spath)){
      stop("Theme `", theme, "` exists but it's empty. Abort.")
    }
    settings <- readLines(submodule_spath)
    # Find submodule
    sel <- startsWith(settings, sprintf("[submodule \"%s\"]", theme))
    if(!any(sel)){
      stop("Theme `", theme, "` is empty. I guess it's a git submodule. However, I cannot locate it in the `.gitmodules` file.")
    }
    settings <- settings[seq(which(sel), length(settings))]
    sel <- which(grepl("\\[submodule", settings))
    if(length(sel) > 1){
      settings <- settings[seq(sel[[1]], sel[[2]] - 1)]
    }
    sel <- grepl("^[^a-zA-Z0-9]url[ =]", settings)
    if(!any(sel)){
      stop("Theme `", theme, "` is a git submodule. However, I cannot locate the URL.")
    }
    url <- settings[sel][[1]]
    if(grepl("url[ =]+http", url)){
      url <- strsplit(url, split = "/")[[1]]
      uname <- url[[length(url) - 1]]
      repo <- url[[length(url)]]
      if(grepl("@", repo)){
        tmp <- strsplit(repo, "@")[[1]]
        repo <- tmp[[1]]
        branch <- tmp[[2]]
      } else {
        sel <- grepl("^[^a-zA-Z0-9]branch[ =]", settings)
        if(any(sel)){
          branch <- settings[sel][[1]]
          branch <- strsplit(branch, "=")[[1]][[2]]
          branch <- sub("[ \t]+", "", branch)
        } else {
          branch <- "main"
        }
      }
    } else if (grepl("url[ =]+git@", url)){
      url <- strsplit(url, split = ":")[[1]]
      url <- unlist(strsplit(url, split = "/"))
      uname <- url[[length(url) - 1]]
      repo <- url[[length(url)]]
      if(grepl("@", repo)){
        tmp <- strsplit(repo, "@")[[1]]
        repo <- tmp[[1]]
        branch <- tmp[[2]]
      } else {
        sel <- grepl("^[^a-zA-Z0-9]branch[ =]", settings)
        if(any(sel)){
          branch <- settings[sel][[1]]
          branch <- strsplit(branch, "=")[[1]][[2]]
          branch <- sub("[ \t]+", "", branch)
        } else {
          branch <- "main"
        }
      }
      if(endsWith(repo, ".git")){
        repo <- sub("\\.git$", "", repo)
      }
    } else {
      stop("Theme `", theme, "` is a git submodule. However, I cannot parse the URL:\n", url)
    }

    re <- use_template(path = path, user = uname, theme = "",
                       repo = repo, branch = branch, ...)
    return(re)
    # https://github.com/dipterix/rave-pipelines/archive/578c8644b2b67623b7efd138a1e5340fc068e725.zip
    # url <- sprintf("https://github.com/%s/%s/archive/%s.zip", uname, repo, branch)
    # unlink(tempzip)
    # if(branch %in% c("main", "master")){
    #   tryCatch({
    #     utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
    #   }, error = function(e){
    #     if(branch == "main"){
    #       branch <- "master"
    #     } else {
    #       branch <- "main"
    #     }
    #     url <- sprintf("https://github.com/%s/%s/archive/%s1.zip", uname, repo, branch)
    #     utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
    #   })
    #
    # } else {
    #   utils::download.file(url, destfile = tempzip, cacheOK = FALSE)
    # }
    #
    # unlink(temppath, recursive = TRUE)
    # utils::unzip(tempzip, exdir = temppath)


  }


  file.copy(fs, path, overwrite = TRUE, recursive = TRUE, copy.date = TRUE)

  # Add RStudio start-up script
  # dput(deparse(quote({
  #   try({
  #     shidashi::template_settings$set(root_path = normalizePath("."))
  #   }, silent = TRUE)
  # })))

  writeLines(
    c(
      "{",
      "    try({",
      "        shidashi::template_settings$set(root_path = normalizePath(\".\"))",
      "    }, silent = TRUE)",
      "}"
    ),
    con = file.path(path, ".Rprofile")
  )

  writeLines(c(
    "library(shidashi)\n",
    "# Render this project",
    sprintf("shidashi::template_settings$set(root_path = '%s')\n", normalizePath(path)),
    "# Render project",
    "shidashi::render(host = '127.0.0.1', port = 8310L)"
  ), con = file.path(path, "start.R"))

  invisible(normalizePath(path))
}


#' @title Configure template options that are shared across the sessions
#' @param ... key-value pair to set options
#' @param name character, key of the value
#' @param default default value if the key is missing
#' @return \code{template_settings_get} returns the values represented by the
#' corresponding keys, or the default value if key is missing.
#' @details The settings is designed to store static key-value pairs that
#' are shared across the sessions. The most important key is
#' \code{"root_path"}, which should be a path pointing to the template
#' folder.
#' @examples
#'
#' # Get current website root path
#'
#' template_root()
#'
#' @export
template_settings <- local({
  map <- fastmap::fastmap()
  list(
    get = function(name, default = NULL){
      map$get(name, missing = default)
    },
    set = function(...){
      map$mset(...)
    },
    list = function(){
      map$as_list()
    }
  )
})

#' @rdname template_settings
#' @export
template_settings_set <- template_settings$set

#' @rdname template_settings
#' @export
template_settings_get <- template_settings$get

#' @rdname template_settings
#' @export
template_root <- function(){
  path <- template_settings$get(
    name = 'root_path',
    default = NULL
  )
  if(!length(path)) {
    if(template_settings$get("dev.debug", FALSE)){
      path <- 'inst/buildin-templates/AdminLTE3/'
    } else {
      path <- file.path(R_user_dir('shidashi', which = "data"), "AdminLTE3")
      if(!dir.exists(path)){
        path <- file.path(R_user_dir('shidashi', which = "data"), "AdminLTE3-bare")
        create_barebone(path)
      }
    }

  }
  normalizePath(path, mustWork = FALSE)
}

sync_inputs <- function(session = shiny::getDefaultReactiveDomain()) {

  shared_id <- session$cache$get("shidashi_shared_id")
  private_id <- session$cache$get("shidashi_private_id")
  if(length(shared_id) != 1 || length(private_id) != 1 ||
     !is.character(shared_id) || !is.character(private_id)){
    stop("Invalid session IDs, run `register_session_id()` first to register.")
  }

  root_session <- session$rootScope()

  reactives <- root_session$cache$get("shidashi_sync_inputs", NULL)

  if(!shiny::is.reactivevalues(reactives)){
    reactives <- shiny::reactiveValues()
    root_session$cache$set("shidashi_sync_inputs", reactives)
  }

  observer <- root_session$cache$get("shidashi_sync_handler", NULL)

  if(is.null(observer)){
    observer <- shiny::observeEvent({
      root_session$input[["@shidashi@"]]
    }, {
      try({
        # if(system.file('', package = "RcppSimdJson") != ''){
        #   message <- RcppSimdJson::fparse(root_session$input[["@shidashi@"]])
        # } else {
          message <- jsonlite::fromJSON(root_session$input[["@shidashi@"]])
        # }


        if(identical(message$last_edit, private_id)){
          return()
        }

        input_names <- shiny::isolate({ names(root_session$input) })
        input_names <- input_names[!startsWith(input_names, "@")]
        input_names <- input_names[input_names %in% names(message$inputs)]
        if(!length(input_names)) { return() }

        lapply(input_names, function(nm){
          v <- message$inputs[[nm]]
          v2 <- shiny::isolate(root_session$input[[nm]])
          if(!identical(v, v2)){
            reactives[[nm]] <- v
          }
        })

        # input_names <- input_names[sel]
        #
        # if(!length(input_names)) { return() }
        #
        # print(message$inputs[input_names])
        # list2env(list(root_session = root_session), envir=.GlobalEnv)
        # do.call(root_session$setInputs, message$inputs[input_names])

      }, silent = FALSE)
    }, domain = root_session, ignoreNULL = TRUE, ignoreInit = TRUE,
    suspended = TRUE)

    root_session$cache$set("shidashi_sync_handler", observer)
  }

  list(
    reactives = reactives,
    sync_observer = observer
  )

}

#' @name javascript-tunnel
#' @title The 'JavaScript' tunnel
#' @param session shiny reactive domain
#' @param shared_id the shared id of the session, usually automatically set
#' @param shared_inputs the input names to share to/from other sessions
#' @param event_data a reactive value list returned by
#' \code{register_session_events}
#' @param type event type; see 'Details'
#' @param default default value if \code{type} is missing
#' @return \code{register_session_id} returns a list of function to control
#' "sharing" inputs with other shiny sessions with the same \code{shared_id}.
#' \code{register_session_events} returns a reactive value list that reflects
#' the session state.
#' \code{get_jsevent} returns events fired by
#' \code{shidashi.broadcastEvent} in 'JavaScript'.
#' \code{get_theme} returns a list of theme, foreground, and background color.
#'
#' @details The \code{register_session_id} should be used in the module
#' server function. It registers a \code{shared_id} and a \code{private_id}
#' to the session. The sessions with the same \code{shared_id} can synchronize
#' their inputs, specified by \code{shared_inputs} even on different browser
#' tabs.
#'
#' \code{register_session_events} will read the session events from 'JavaScript'
#' and passively update these information. Any the event fired by
#' \code{shidashi.broadcastEvent} in 'JavaScript' will be available as
#' reactive value. \code{get_jsevent} provides a convenient way to read
#' these events provided the right
#' event types. \code{get_theme} is a special \code{get_jsevent} that with
#' event type \code{"theme.changed"}.
#'
#' Function \code{register_session_id} and \code{register_session_events}
#' should be called at the beginning of server functions. They can be
#' called multiple times safely. Function
#' \code{get_jsevent} and \code{get_theme} should be called in reactive
#' contexts (such as \code{\link[shiny]{observe}},
#' \code{\link[shiny]{observeEvent}}).
#'
#' @examples
#'
#' # shiny server function
#'
#' library(shiny)
#' server <- function(input, output, session){
#'   sync_tools <- register_session_id(session = session)
#'   event_data <- register_session_events(session = session)
#'
#'   # if you want to enable syncing. They are suspended by default
#'   sync_tools$enable_broadcast()
#'   sync_tools$enable_sync()
#'
#'   # get_theme should be called within reactive context
#'   output$plot <- renderPlot({
#'     theme <- get_theme(event_data)
#'     mar(bg = theme$background, fg = theme$foreground)
#'     plot(1:10)
#'   })
#'
#' }
#'
NULL

#' @title Register global reactive list
#' @description Creates or get reactive value list that is shared within the same
#' shiny session
#' @param name character, the key of the list
#' @param session shiny session
#' @return A shiny \code{\link[shiny]{reactiveValues}} object
#' @export
register_global_reactiveValues <- function(name, session = shiny::getDefaultReactiveDomain()){
  if(is.null(session)){
    return(shiny::reactiveValues())
  }
  root_session <- session$rootScope()
  event_data <- root_session$cache$get(name, NULL)
  if(!shiny::is.reactivevalues(event_data)){
    event_data <- shiny::reactiveValues()
    root_session$cache$set(name, event_data)
  }
  event_data
}



#' @rdname javascript-tunnel
#' @export
register_session_id <- function(
  session = shiny::getDefaultReactiveDomain(),
  shared_id = NULL,
  shared_inputs = NA){

  if(length(shared_id)){
    if(grepl("[^a-z0-9_]", shared_id)){
      stop("session `shared_id` must only contain letters (lower-case), digits, and/or '_'.")
    }
  } else {
    # obtain the shared ID
    shared_id <- session$cache$get("shidashi_shared_id", NULL)
    if(length(shared_id) != 1 || !is.character(shared_id)){
      # get from session
      query_list <- httr::parse_url(shiny::isolate(session$clientData$url_search))
      shared_id <- query_list$query$shared_id
      shared_id <- tolower(shared_id)
      if(!length(shared_id) || grepl("[^a-z0-9_]", shared_id)){
        shared_id <- rand_string(length = 26)
        shared_id <- tolower(shared_id)
      }
    }
  }
  session$cache$set("shidashi_shared_id", shared_id)

  if(!session$cache$exists("shidashi_private_id")){
    is_registerd <- FALSE
    private_id <- rand_string(length = 8)
    session$cache$set("shidashi_private_id", private_id)
  } else {
    is_registerd <- TRUE
    private_id <- session$cache$get("shidashi_private_id")
  }

  # set up shared_id bucket
  broadcast_observer <- session$cache$get(
    "shidashi_broadcast_handler", NULL)

  if( is.null(broadcast_observer) ){
    broadcast_observer <- shiny::observe({
      inputs <- shiny::reactiveValuesToList(session$input)
      nms <- names(inputs)

      sel <- !startsWith(nms, "@")
      if(length(sel) && any(sel)){
        nms <- nms[sel]
        inputs <- inputs[sel]
        names(inputs) <- session$ns(nms)
        sig <- session$cache$get("shidashi_input_signature", NULL)
        sig2 <- digest::digest(inputs)
        if(!identical(sig2, sig)){
          session$cache$set("shidashi_input_signature", sig2)
          message <- list(
            shared_id = shared_id,
            private_id = private_id,
            inputs = inputs
          )
          session$sendCustomMessage("shidashi.cache_session_input", message)
        }

      }
    }, domain = session, priority = -100000, suspended = TRUE)

    session$cache$set(
      "shidashi_broadcast_handler", broadcast_observer)

  }

  res <- sync_inputs(session = session)
  res$broadcast_observer <- broadcast_observer

  res$disable_broadcast <- function(){
    res$broadcast_observer$suspend()
  }
  res$enable_broadcast <- function(once = FALSE){
    if(once){
      res$broadcast_observer$run()
    } else {
      res$broadcast_observer$resume()
    }
  }
  res$disable_sync <- function(){
    res$sync_observer$suspend()
  }
  res$enable_sync <- function(once = FALSE){
    if(once){
      res$sync_observer$run()
    } else {
      res$sync_observer$resume()
    }
  }

  res
}

#' @rdname javascript-tunnel
#' @export
register_session_events <- function(session = shiny::getDefaultReactiveDomain()){
  if(is.environment(session)){
    root_session <- session$rootScope()

    event_data <- root_session$cache$get("shidashi_event_data", NULL)
    if(!shiny::is.reactivevalues(event_data)){
      event_data <- shiny::reactiveValues()
      root_session$cache$set("shidashi_event_data", event_data)
    }

    observer <- root_session$cache$get("shidashi_event_handler", NULL)

    if(is.null(observer)){
      observer <- shiny::observeEvent({
        root_session$input[["@shidashi_event@"]]
      }, {
        event <- root_session$input[["@shidashi_event@"]]
        if(is.list(event) && length(event$type) == 1 && is.character(event$type) ){
          event_data[[event$type]] <- event$message
        }
      }, domain = root_session)

      session$sendCustomMessage("shidashi.get_theme", list())

    }
  } else {
    event_data <- list()
  }
  event_data
}


#' @rdname javascript-tunnel
#' @export
get_theme <- function(event_data, session = shiny::getDefaultReactiveDomain()){
  get_jsevent(event_data, "theme.changed", list(
    theme = "light",
    background = "#FFFFFF",
    foreground = "#000000"
  ), session = session)
}

#' @rdname javascript-tunnel
#' @export
get_jsevent <- function(event_data, type, default = NULL,
                        session = shiny::getDefaultReactiveDomain()){
  if(shiny::is.reactivevalues(event_data)){
    shiny::withReactiveDomain(domain = session, {
      if(is.list(event_data[[type]])){
        return(event_data[[type]])
      } else {
        return(default)
      }
    })
  } else {
    return(default)
  }
}





#' @name adminlte
#' @title Generates 'AdminLTE' theme-related 'HTML' tags
#' @description These functions should be called in 'HTML' templates.
#' Please see vignettes for details.
#' @param root_path the root path of the website project; see
#' \code{\link{template_settings}}
#' @param settings_file the settings file containing the module information
#' @param shared_id a shared identification by session to synchronize the
#' inputs; assigned internally.
#' @return 'HTML' tags
#' @export
adminlte_ui <- function(root_path = template_root()){
  function(req){

    tryCatch({
      resource <- load_module(root_path = root_path, request = req)
      env <- new.env(parent = resource$environment)

      if(resource$has_module){
        # load module UI
        template_path <- resource$module$template_path
      } else {
        if(!length(resource$module$id)){
          # load overall UI
          template_path <- resource$template_path
        } else {
          # 404
          template_path <- file.path(root_path, 'views', '404.html')
          if(!file.exists(template_path)){
            return("Page not found (404)")
          }
        }
      }

      `@args` <- as.list(resource$environment, all.names = TRUE)
      `@args`$filename <- template_path
      call <- as.call(c(list(quote(shiny::htmlTemplate)), `@args`))
      return(eval(call, envir = env))
    }, error = function(e){
      module_template <- file.path(root_path, 'views', '500.html')
      error <- shiny::pre(
        style = "word-wrap: break-word; white-space: break-spaces;",
        paste(
          sep = "\n",
          "Error message:",
          e$message,
          "Traceback:",
          paste(utils::capture.output({
            traceback(e)
          }), collapse = "\n")
        )
      )
      if(file.exists(module_template)){

        return(shiny::htmlTemplate(module_template, error = error, req = req))
      } else {
        return(paste("Internal error: <br/>", error))
      }
    })

  }

}


#' @rdname adminlte
#' @export
adminlte_sidebar <- function(root_path = template_root(),
                             settings_file = "modules.yaml",
                             shared_id = rand_string(26)){
  settings <- yaml::read_yaml(file.path(root_path, settings_file))
  # settings <- yaml::read_yaml('modules.yaml')

  divider <- settings$divider
  if(length(divider)){
    divider <- data.frame(
      name = names(divider),
      order = sapply(divider, function(x){ if(isTRUE(is.numeric(x$order))){x$order}else{NA} })
    )
    divider <- divider[!is.na(divider$order), ]
  }
  if(!length(divider) || !nrow(divider)){
    divider <- data.frame(name = "END", order = Inf)
  }

  groups <- settings$groups
  if(length(groups)){
    groups <- groups[names(groups) != '']
  }
  group_icons <- sapply(groups, function(x){ ifelse(length(x$icon) == 1, x$icon, "") })
  group_badge <- sapply(groups, function(x){ ifelse(length(x$badge) == 1, x$badge, "") })
  group_order <- sapply(groups, function(x){ ifelse(length(x$order) == 1, x$order, NA) })
  group_open <- sapply(groups, function(x){ isTRUE(x$open) })
  groups <- names(groups)

  modules <- settings$modules
  modules_ids <- names(settings$modules)

  groups <- unique(groups)
  group_level <- factor(groups, levels = groups, ordered = TRUE)

  module_tbl <- do.call('rbind', lapply(modules_ids, function(mid){
    x <- modules[[mid]]
    if(isTRUE(x$hidden)) {
      return(NULL)
    }
    y <- x[!names(x) %in% c('order', 'group', 'label', 'icon', 'badge', 'module', 'hidden')]
    y$module <- mid
    y$shared_id <- shared_id
    url <- httr::modify_url("?module=", query = y)
    order <- x$order
    if(!length(order) || is.na(order)){
      order <- 9999L
    }

    if(length(x$group) == 1 && x$group %in% group_level){
      x$group <- group_level[group_level == x$group][[1]]
      renderOrder <- group_order[group_level == x$group][[1]] + order / 10000
    } else {
      x$group <- NA
      renderOrder <- order
    }


    data.frame(
      id = mid,
      order = order,
      renderOrder = renderOrder,
      group = x$group,
      label = ifelse(length(x$label) == 1, x$label, "No Label"),
      icon = ifelse(length(x$icon) == 1, x$icon, ""),
      badge = ifelse(length(x$badge) == 1, x$badge, ""),
      url = gsub("^[^\\?]+", "", url),
      stringsAsFactors = FALSE
    )
  }))

  if(nrow(module_tbl)){
    max_order <- max(c(module_tbl$renderOrder, 10000), na.rm = TRUE) + 1
    # group could be NA, resulting in warning
    suppressWarnings({
      module_tbl <- module_tbl[
        order(module_tbl$renderOrder),
      ]
    })
  }

  side_bar <- list()
  ignore_group <- NULL
  last_order <- -Inf

  for(i in seq_len(nrow(module_tbl))){
    x <- module_tbl[i, ]

    current_order <- x$renderOrder

    divide_item <- divider[divider$order <= current_order & divider$order > last_order,]
    if(nrow(divide_item)){
      for(j in seq_len(nrow(divide_item))){
        tmp <- divide_item[j, ]
        side_bar[[length(side_bar) + 1]] <- shiny::tags$li(
          class="nav-header nav-divider",
          shiny::span(
            tmp$name
          )
        )
      }
    }
    last_order <- current_order

    if(is.na(x$group)){
      item <- menu_item(text = x$label, icon = x$icon, href = x$url, badge = x$badge)
      side_bar[[length(side_bar) + 1]] <- item
    } else if(!as.character(x$group) %in% ignore_group){

      # add group
      group <- x$group
      ignore_group <- c(ignore_group, as.character(group))
      sub <- module_tbl[!is.na(module_tbl$group) & module_tbl$group == group, ]
      if(nrow(sub)){

        menu <- lapply(seq_len(nrow(sub)), function(ii){
          x <- sub[ii, ]
          menu_item(text = x$label, icon = x$icon, href = x$url, badge = x$badge)
        })
        sel <- which(groups %in% group)[[1]]
        item <- menu_item_dropdown(text = group, .list = menu,
                                   icon = group_icons[sel],
                                   badge = group_badge[sel],
                                   active = group_open[sel])
        side_bar[[length(side_bar) + 1]] <- item
      }

    }
  }

  shiny::tagList(side_bar)

  # shiny::tagList(
  #   lapply(seq_along(groups), function(ii){
  #     group <- groups[[ii]]
  #     sub <- module_tbl[!is.na(module_tbl$group) & module_tbl$group == group, ]
  #     if(!nrow(sub)){ return(NULL) }
  #     menu <- lapply(seq_len(nrow(sub)), function(ii){
  #       x <- sub[ii, ]
  #       menu_item(text = x$label, icon = x$icon, href = x$url, badge = x$badge)
  #     })
  #     menu_item_dropdown(text = group, .list = menu, icon = group_icons[[ii]], badge = group_badge[[ii]])
  #   }),
  #   local({
  #     sub <- module_tbl[is.na(module_tbl$group), ]
  #     if(!nrow(sub)){ return(NULL) }
  #     lapply(seq_len(nrow(sub)), function(ii){
  #       x <- sub[ii, ]
  #       menu_item(text = x$label, icon = x$icon, href = x$url, badge = x$badge)
  #     })
  #   })
  # )
}

# From my own dipsaus package


#' @title Generate 'HTML' tags with 'flex' layout
#' @param ... for \code{flex_container}, it's elements of \code{flex_item};
#' for \code{flex_item}, \code{...} are shiny 'HTML' tags
#' @param size numerical relative size of the item; will be ignored if
#' \code{flex} is provided
#' @param style the additional 'CSS' style for containers or inner items
#' @param direction,wrap,justify,align_box,align_content 'CSS' styles for
#' 'flex' containers
#' @param order,align,flex CSS' styles for 'flex' items
#' @param class,.class class to add to the elements
#' @return 'HTML' tags
#'
#' @examples
#'
#' x <- flex_container(
#'   style = "position:absolute;height:100vh;top:0;left:0;width:100%",
#'   flex_item(style = 'background-color:black;'),
#'   flex_item(style = 'background-color:red;')
#' )
#' # You can view it via `htmltools::html_print(x)`
#'
#' @export
flex_container <- function(
  ...,
  style = NULL,
  direction = c("row", "column"),
  wrap = c("wrap", "nowrap", "wrap-reverse"),
  justify = c("flex-start", "center", "flex-end", "space-around", "space-between"),
  align_box = c("stretch", "flex-start", "center", "flex-end", "baseline"),
  align_content = c("stretch", "flex-start", "flex-end", "space-between", "space-around", "center")
){
  call <- match.call(expand.dots = FALSE)
  style1 <- style
  style <- list()

  direction <- match.arg(direction)
  style[["flex-direction"]] <- direction

  wrap <- match.arg(wrap)
  style[["flex-wrap"]] <- wrap

  justify <- match.arg(justify)
  style[["justify-content"]] <- justify

  align_box <- match.arg(align_box)
  style[["align-content"]] <- align_box

  align_content <- match.arg(align_content)
  style[["align-items"]] <- align_content

  style$display <- "flex"
  style <- paste(names(style), as.vector(style), sep = ":", collapse = "; ")
  if(length(style1)){
    style <- paste0(style, "; ", style1)
  }


  shiny::div(style = style, ...)
}

#' @rdname flex_container
#' @export
flex_item <- function(
  ..., size = 1,
  style = NULL, order = NULL, flex = as.character(size),
  align = c("flex-start", "flex-end", "center"),
  class = NULL,
  .class = "fill-width padding-5"
){
  l <- list()
  if(length(align) == 1){
    align <- match.arg(align)
    l[["align-self"]] <- align
  }
  l[['order']] <- order
  l[['flex']] <- flex

  style1 <- paste(names(l), as.vector(l), sep = ":", collapse = "; ")
  if(length(style)){
    style1 <- paste0(style1, "; ", style)
  }

  class <- combine_class(class, .class)

  shiny::div(
    ...,
    style = style1,
    class = class
  )

}

#' @rdname flex_container
#' @export
flex_break <- function(..., class = NULL){
  class <- combine_class(class, "flex-break")
  shiny::div(class = class, ...)
}

#' 'HTML' code to generate small back-to-top button
#' @description This function is a template function that should be called
#' in 'HTML' templates before closing the \code{"</body>"} tag.
#' @param icon the icon for back-to-top button
#' @param title the expanded menu title
#' @return 'HTML' tags
#'
#' @examples
#'
#' back_top_button()
#' back_top_button("rocket")
#'
#' @export
back_top_button <- function(icon = "chevron-up", title = "Jump to"){
  if(!length(title)){
    title <- NULL
  } else {
    title <- shiny::h6(class="dropdown-header", title)
  }
  shiny::div(
    class = "back-to-top",
    shiny::div(
      class = "btn-group dropup",
      role="group",
      shiny::a(
        type="button", class="btn btn-default btn-go-top border-right-1", href="#",
        as_icon(icon)
      ),
      shiny::tags$button(
        type="button",
        class="btn btn-default dropdown-toggle dropdown-toggle-split border-left-1" ,
        "data-toggle"="dropdown",
        "aria-haspopup"="false",
        "aria-expanded"="false",
        shiny::span(
          class = "sr-only",
          "Dropdown-Open"
        )
      ),
      shiny::div(
        class = "dropdown-menu dropdown-menu-right",
        title
      )
    )
  )
}



#' @name add-remove-html-class
#' @title Add or remove 'HTML' class from 'RAVE' application
#' @description Only works in template framework provided by 'shidashi' package,
#' see \code{\link[shidashi]{use_template}}
#' @param selector 'CSS' selector
#' @param class class to add or to remove from selected elements
#' @param session shiny session
#' @return No value is returned
#'
#' @examples
#'
#' server <- function(input, output, session){
#'
#'   # Add class `hidden` to element with ID `elemid`
#'   add_class("#elemid", "hidden")
#'
#'   # Remove class `hidden` from element with class `shiny-input-optional`
#'   remove_class(".shiny-input-optional", "hidden")
#' }
#'
#' @export
add_class <- function(selector, class,
                      session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage("shidashi.add_class", list(
    selector = selector,
    class = class
  ))
}

#' @rdname add-remove-html-class
#' @export
remove_class <- function(selector, class,
                         session = shiny::getDefaultReactiveDomain()){
  session$sendCustomMessage("shidashi.remove_class", list(
    selector = selector,
    class = class
  ))
}


#' @importFrom fastmap fastmap
#' @importFrom digest digest
#' @importFrom formatR tidy_source
#' @importFrom httr parse_url
#' @importFrom httr modify_url
#' @importFrom yaml read_yaml
#' @importFrom jsonlite fromJSON
NULL

rand_string <- function (length = 10) {
  paste(sample(c(letters, LETTERS, 0:9), length, replace = TRUE),
        collapse = "")
}

R_user_dir <- function (package, which = c("data", "config", "cache"))
{
  stopifnot(is.character(package), length(package) == 1L)
  which <- match.arg(which)
  home <- normalizePath("~")
  path <- switch(which, data = {
    p <- Sys.getenv("R_USER_DATA_DIR")
    if (!nzchar(p)) {
      p <- Sys.getenv("XDG_DATA_HOME")
      if (!nzchar(p)) {
        if (.Platform$OS.type == "windows") {
          p <- file.path(Sys.getenv("APPDATA"), "R",
                         "data")
        } else if (Sys.info()["sysname"] == "Darwin") {
          p <- file.path(home, "Library", "Application Support",
                         "org.R-project.R")
        } else {
          p <- file.path(home, ".local", "share")
        }
      }
    }
    p
  }, config = {
    p <- Sys.getenv("R_USER_CONFIG_DIR")
    if (!nzchar(p)) {
      p <- Sys.getenv("R_USER_CONFIG_DIR")
      if (!nzchar(p)) {
        p <- Sys.getenv("XDG_CONFIG_HOME")
        if (!nzchar(p)) {
          if (.Platform$OS.type == "windows") {
            p <- file.path(Sys.getenv("APPDATA"), "R",
                           "config")
          } else if (Sys.info()["sysname"] == "Darwin") {
            p <- file.path(home, "Library", "Preferences",
                           "org.R-project.R")
          } else {
            p <- file.path(home, ".config")
          }
        }
      }
    }
    p
  }, cache = {
    p <- Sys.getenv("R_USER_CACHE_DIR")
    if (!nzchar(p)) {
      p <- Sys.getenv("XDG_CACHE_HOME")
      if (!nzchar(p)) {
        if (.Platform$OS.type == "windows") {
          p <- file.path(Sys.getenv("LOCALAPPDATA"),
                         "R", "cache")
        } else if (Sys.info()["sysname"] == "Darwin") {
          p <- file.path(home, "Library", "Caches", "org.R-project.R")
        } else {
          p <- file.path(home, ".cache")
        }
      }
    }
    p
  })
  file.path(path, "R", package)
}

set_attr_call <- function(x, call, collapse = "\n", ...) {
  if(!is.character(call)){
    call <- deparse(call)
  }
  call <- paste(call, collapse = collapse, ...)
  attr(x, "shidashi.code") <- call
  x
}

combine_class <- function(...){
  s <- paste(c(...), collapse = " ", sep = " ")
  s <- unlist(strsplit(s, " "))
  s <- unique(s)
  s <- s[!s %in% '']
  paste(s, collapse = " ")
}
remove_html_class <- function(target, class){
  if (!length(target)) { return("") }
  s <- unlist(strsplit(target, " "))
  s <- unique(s)
  s <- s[!s %in% c('', class)]
  paste(s, collapse = " ")
}

#' Guess the 'AdminLTE' body class for modules, used internally
#' @param cls the class string of the \code{<body>} tag in \code{'index.html'}
#' @return The proposed class for \code{<body>} tag
#' @export
guess_body_class <- function(cls){
  if(missing(cls)){
    cls <- "fancy-scroll-y darm-mode"
  } else {
    cls <- unlist(strsplit(paste(cls, collapse = ' '), " "))
    combine_class(cls[startsWith(cls, "fancy-scroll-") | cls %in% 'dark-mode'])
  }
}

#' Get \code{R} expression used to generate the 'HTML' tags
#' @description This function only works on the elements generated by this
#' package
#' @param x 'HTML' tags
#' @return Quoted \code{R} expressions that can generate the 'HTML' tags
#'
#' @seealso \code{\link{format_text_r}}
#' @examples
#'
#' x <- info_box("Message")
#' get_construct_string(x)
#'
#' @export
get_construct_string <- function(x){
  attr(x, "shidashi.code")
}

#' Get re-formatted \code{R} expressions in characters
#' @seealso \code{\link{get_construct_string}}
#' @param expr \code{R} expressions
#' @param quoted whether \code{expr} is quoted
#' @param reformat whether to reformat
#' @param class class of \code{<pre>} tag
#' @param copy_on_click whether to copy to clipboard if user clicks on the
#' code; default is true
#' @param hover mouse hover behavior
#' @param width.cutoff,indent,wrap,args.newline,blank,... passed to
#' \code{\link[formatR]{tidy_source}}
#' @return \code{format_text_r} returns characters,
#' \code{html_highlight_code} returns the 'HTML' tags wrapping expressions
#' in \code{<pre>} tag
#' @examples
#'
#' s <- format_text_r(print(local({a<-1;a+1})))
#' cat(s)
#'
#' x <- info_box("Message", icon = "cogs")
#' s <- format_text_r(get_construct_string(x),
#'                    width.cutoff = 15L, quoted = TRUE)
#' cat(s)
#'
#'
#' @export
format_text_r <- function(expr, quoted = FALSE, reformat = TRUE,
                          width.cutoff = 80L, indent = 2, wrap=TRUE,
                          args.newline = TRUE, blank = FALSE, ...){
  if(!quoted){
    expr <- substitute(expr)
  }

  if(length(expr) !=1 || !is.character(expr)){
    expr <- paste(deparse(expr), collapse = "\n")
  }

  if(reformat){
    expr <- formatR::tidy_source(
      text = expr, output = FALSE,
      width.cutoff = width.cutoff, indent = indent, wrap=wrap,
      args.newline = args.newline, blank = blank,
      ...
    )$text.tidy
  }
  paste(expr, collapse = "\n")
}

#' @rdname format_text_r
#' @export
html_highlight_code <- function(
  expr, class = NULL, quoted = FALSE,
  reformat = TRUE, copy_on_click = TRUE,
  width.cutoff = 80L, indent = 2, wrap=TRUE,
  args.newline = TRUE, blank = FALSE,
  ..., hover = c("overflow-visible-on-hover", "overflow-auto")){

  hover <- match.arg(hover)
  if(!quoted){
    expr <- substitute(expr)
  }
  expr <- format_text_r(expr = expr, quoted = TRUE,
                reformat = reformat, width.cutoff = width.cutoff,
                indent = indent, wrap = wrap, args.newline = args.newline,
                blank = blank, ...)

  shiny::HTML(
    sprintf(
      "<pre class='pre-compact no-padding bg-gray-90 %s %s %s' %s><code class='r'>%s</code></pre>",
      hover,
      paste(class, collapse = " "),
      ifelse(copy_on_click, "clipboard-btn shidashi-clipboard-output", ""),
      ifelse(copy_on_click,
             sprintf("data-clipboard-text='%s' role='button' title='Click to copy!'", expr),
             ""),
      expr
    )
  )
}

#' Used by demo project to show the generating code
#' @seealso \code{html_highlight_code}
#' @description Please write your own version. This function is designed for
#' demo-use only.
#' @param x 'HTML' tags generated by this package
#' @param class additional 'HTML' class
#' @param code_only whether to show code only
#' @param as_card whether to wrap results in \code{\link{card}}
#' @param card_title,class_body used by \code{\link{card}} if \code{as_card=TRUE}
#' @param width.cutoff,indent,wrap,args.newline,blank,copy_on_click,... passed
#' to \code{\link{html_highlight_code}}
#' @return 'HTML' tags
#' @export
show_ui_code <- function(
  x, class = NULL, code_only = FALSE,
  as_card = FALSE, card_title = "", class_body = "bg-gray-70",
  width.cutoff = 80L, indent = 2, wrap=TRUE,
  args.newline = TRUE, blank = FALSE, copy_on_click = TRUE,
  ...)
{
  code <- format_text_r(
    get_construct_string(x),
    quoted = TRUE,
    width.cutoff = width.cutoff,
    indent = indent,
    wrap = wrap,
    args.newline = args.newline,
    blank = blank,
    ...
  )

  res <- info_box(
    class = combine_class("no-margin overflow-visible-on-hover", class),
    class_content = "display-block bg-gray-90 no-padding code-display",
    icon = NULL,
    html_highlight_code(code, quoted = TRUE, reformat = FALSE,
                        copy_on_click = copy_on_click)
  )


  if(as_card){
    res <- card(
      title = card_title, class_body = class_body,
      tools = clipboardOutput(
        clip_text = code,
        as_card_tool = TRUE),
      footer = res,
      class_foot = "display-block bg-gray-90 no-padding code-display fill-width",
      if(code_only){ NULL }else{x}
    )
  }
  res
}



#' @title 'Accordion' items
#' @param title character title to show in the header
#' @param ... body content
#' @param footer footer element, hidden if \code{NULL}
#' @param tools a list of badge or tool icons generated by
#' \code{\link{card_tool}} or \code{\link{as_badge}}
#' @param class the class of the item
#' @param collapsed whether collapsed at the beginning
#' @param parentId parent \code{\link{accordion}} id
#' @param itemId the item id
#' @param style_header,style_body 'CSS' style of item header and body
#' @param root_path see \code{template_root}
#' @return \code{'shiny.tag.list'} 'HTML' tags
#' @seealso \code{\link{accordion}}
#' @export
accordion_item <- function(
  title, ..., footer = NULL, tools = NULL,
  class = "", collapsed = TRUE,
  parentId = rand_string(), itemId = rand_string(),
  style_header = NULL, style_body = NULL,
  root_path = template_root()){

  body <- shiny::tagList(...)

  template_path <- file.path(root_path, 'views', 'accordion-item.html')

  if(length(footer)){
    footer <- shiny::div(
      class = "card-footer",
      footer
    )
  } else {
    footer <- ''
  }

  if(length(tools)){
    tools <- shiny::div(
      class = "card-tools card-accordion",
      tools
    )
  } else {
    tools <- ""
  }

  shiny::htmlTemplate(
    template_path,
    document_ = FALSE,
    title = title,
    body = body,
    class = class,
    parentId = parentId,
    itemId = itemId,
    style_header = style_header,
    style_body = style_body,
    footer = footer,
    tools = tools,
    collapsed = collapsed
  )
}

#' @name accordion
#' @title Generates an 'accordion' tab-set
#' @description Generates an 'accordion' tab-set that only one tab is
#' expanded at a time. This feature is experimental and has bugs in
#' some situations. Please use it at your own risk.
#' @param ... 'accordion' items, generated by \code{\link{accordion_item}}
#' @param id the element id, must be unique
#' @param class the additional 'HTML' class
#' @param style_header additional 'CSS' styles for header
#' @param style_body additional 'CSS' styles for content body
#' @param env environment to evaluate \code{...}
#' @param extras key-value pairs that overrides the parameters in
#' \code{\link{accordion_item}}
#' @param root_path see \code{\link{template_root}}
#' @return \code{'shiny.tag.list'} 'HTML' tags
#' @seealso \code{\link{accordion_item}}
#'
#' @examples
#'
#' library(shiny)
#' library(shidashi)
#'
#' accordion(
#'   id = "input-set",
#'   accordion_item(
#'     title = "Input Group A",
#'     textInput("input_1", "Input 1"),
#'     collapsed = FALSE,
#'     footer = "Anim pariatur cliche reprehenderit dolor brunch.",
#'     tools = list(
#'       as_badge("New|badge-danger")
#'       # card_tool(widget = "collapse")
#'     )
#'   ),
#'   accordion_item(
#'     title = "Input Group B",
#'     textInput("input_2", "Input 2"),
#'     footer = actionButton("btn1", "OK"),
#'     collapsed = FALSE,
#'     tools = list(
#'       card_tool(widget = "link",
#'                 icon = shiny::icon("question-circle"),
#'                 href = "#")
#'     )
#'   )
#' )
#'
#' @export
accordion <- function(
  ..., id = rand_string(),
  class = NULL, style_header = NULL,
  style_body = NULL, env = parent.frame(), extras = list(),
  root_path = template_root()){

  call <- match.call(expand.dots = FALSE)

  force(root_path)
  parentId <- id

  items <- unname(lapply(call[['...']], function(item){
    item[["parentId"]] <- parentId
    item[["root_path"]] <- root_path

    if(!is.null(class)){
      item[["class"]] <- class
    }

    if(!is.null(style_header)){
      item[["style_header"]] <- style_header
    }
    if(!is.null(style_body)){
      item[["style_body"]] <- style_body
    }
    eval(item, envir = env)
  }))

  extras <- as.list(extras)
  extras$id <- parentId
  extras <- c(extras, items)

  do.call(shiny::div, extras)

}


create_barebone <- function(path){
  dir.create(path, showWarnings = FALSE, recursive = TRUE)
  src <- system.file("builtin-templates", "AdminLTE3-bare", package = "shidashi")
  fs <- list.files(src, full.names = TRUE, recursive = FALSE, all.files = FALSE,
                   no.. = TRUE, include.dirs = TRUE)
  file.copy(
    from = fs,
    to = path,
    overwrite = TRUE,
    recursive = TRUE,
    copy.date = TRUE
  )

  # /server.R
  {
    writeLines(
      c(
        "{",
        "    library(shiny)",
        "    server <- function(input, output, session) {",
        "        shiny::observeEvent(session$clientData$url_search, {",
        "            req <- list(QUERY_STRING = session$clientData$url_search)",
        "            resource <- shidashi::load_module(request = req)",
        "            if (resource$has_module) {",
        "                module_table <- shidashi::module_info()",
        "                module_table <- module_table[module_table$id %in% ",
        "                  resource$module$id, ]",
        "                if (nrow(module_table)) {",
        "                  group_name <- as.character(module_table$group[[1]])",
        "                  if (is.na(group_name)) {",
        "                    group_name <- \"<no group>\"",
        "                  }",
        "                  if (system.file(package = \"logger\") != \"\") {",
        "                    logger::log_info(\"Loading - { module_table$label[1] } ({group_name}/{ module_table$id })\")",
        "                  }",
        "                  shiny::moduleServer(resource$module$id, resource$module$server, ",
        "                    session = session)",
        "                }",
        "            }",
        "        })",
        "    }",
        "}"
      ), file.path(path, "server.R"))

  }

  dir.create(file.path(path, 'R'), showWarnings = FALSE, recursive = TRUE)
  dir.create(file.path(path, 'modules', 'module_id', 'R'), showWarnings = FALSE, recursive = TRUE)

  # /R/common.R
  {
    writeLines(
      c(
        "library(shiny)",
        "page_title <- function(complete = TRUE){",
        "  if(complete){",
        "    \"Shiny Dashboard Template - Barebone\"",
        "  } else {",
        "    \"ShiDashi\"",
        "  }",
        "}",
        "page_logo <- function(size = c(\"normal\", \"small\", \"large\")){",
        "  # Relative path to your logo icon in www/",
        "  # \"shidashi/img/icon.png\"",
        "  NULL",
        "}",
        "page_loader <- function(){",
        "  # if no loader is needed, then return NULL",
        "  shiny::div(",
        "    class = \"preloader flex-column justify-content-center align-items-center\",",
        "    shiny::img(",
        "      class = \"animation__shake\",",
        "      src = page_logo(\"large\"),",
        "      alt = \"Logo\", height=\"60\", width=\"60\"",
        "    )",
        "  )",
        "}",
        "body_class <- function(){",
        "  c(",
        "    #--- Fix the navigation banner ---",
        "    #\"layout-navbar-fixed\",",
        "",
        "    #--- Collapse the sidebar at the beginning ---",
        "    # \"sidebar-collapse\",",
        "",
        "    #--- Let control sidebar open at the beginning ---",
        "    # \"control-sidebar-slide-open\",",
        "",
        "    #--- Fix the sidebar position ---",
        "    \"layout-fixed\",",
        "",
        "    #--- Default behavior when collapsing sidebar",
        "    # \"sidebar-mini\", \"sidebar-mini-md\", \"sidebar-mini-xs\"",
        "",
        "    #--- Hide the navbar-nav-iframe",
        "    \"navbar-iframe-hidden\",",
        "",
        "    #--- Start as dark-mode ---",
        "    \"dark-mode\"",
        "",
        "    #--- Make scrollbar thinner ---",
        "    # \"fancy-scroll-y\"",
        "",
        "  )",
        "}",
        "nav_class <- function(){",
        "  c(",
        "    \"main-header\",",
        "    \"navbar\",",
        "    \"navbar-expand\",",
        "    \"navbar-dark\",",
        "    \"navbar-primary\"",
        "  )",
        "}",
        "",
        "module_breadcrumb <- function(){}"
      ),
      con = file.path(path, 'R', 'common.R'))
  }

  # /modules/module_id/R/chunk-1.R
  {
    writeLines(
      c(
        "library(shiny)",
        "library(shidashi)",
        "ui <- function(){",
        "",
        "  fluidPage(",
        "    fluidRow(",
        "      column(",
        "        width = 12L,",
        "",
        "        # remember to add ns, which is given as shiny::NS(\"module_id\")",
        "        plotOutput(ns(\"plot\"))",
        "      )",
        "    )",
        "  )",
        "",
        "}",
        "",
        "server_chunk_1 <- function(input, output, session, ...){",
        "",
        "  event_data <- register_session_events()",
        "",
        "  output$plot <- renderPlot({",
        "    theme <- get_theme(event_data)",
        "    set.seed(1)",
        "    par(",
        "      bg = theme$background, fg = theme$foreground,",
        "      col.main = theme$foreground,",
        "      col.axis = theme$foreground,",
        "      col.lab = theme$foreground",
        "    )",
        "    hist(rnorm(1000))",
        "  })",
        "",
        "}"
      ),
      con = file.path(path, 'modules', 'module_id', 'R', "chunk-1.R")
    )
  }

  # /modules/module_id/server.R
  {
    writeLines(
      c(
        "library(shiny)",
        "library(shidashi)",
        "",
        "server <- function(input, output, session, ...){",
        "",
        "  shared_data <- shidashi::register_session_id(session)",
        "",
        "  server_chunk_1(input, output, session, ...)",
        "",
        "}"
      ),
      con = file.path(path, 'modules', 'module_id', 'server.R')
    )
  }

  invisible()

}
